<script>
    // Enhanced tracking component (no changes)
    AFRAME.registerComponent('enhanced-tracking', {
      init: function () {
        this.targetFound = false;
        this.positionBuffer = [];
        this.quaternionBuffer = [];
        this.maxBufferSize = 5; // Number of frames to average for position smoothing
        this.smoothingFactor = 0.3; // Recommended range: 0.1 to 0.8
        this.lastPosition = null;
        this.lastQuaternion = null;

        this.el.addEventListener('targetFound', () => {
          this.targetFound = true;
          this.positionBuffer = [];
          this.quaternionBuffer = [];
          this.lastPosition = this.el.object3D.position.clone();
          this.lastQuaternion = this.el.object3D.quaternion.clone();
          console.log('✅ Target found: Initializing smoothing');
        });

        this.el.addEventListener('targetLost', () => {
          this.targetFound = false;
          console.log('❌ Target lost: Stopping smoothing');
        });
      },
      tick: function () {
        if (!this.targetFound) return;
        const currentPosition = this.el.object3D.position.clone();
        const currentQuaternion = this.el.object3D.quaternion.clone();

        if (!this.lastPosition || !this.lastQuaternion) {
            this.lastPosition = currentPosition.clone();
            this.lastQuaternion = currentQuaternion.clone();
            return; 
        }
        this.positionBuffer.push(currentPosition);
        if (this.positionBuffer.length > this.maxBufferSize) {
          this.positionBuffer.shift();
        }
        let averagedPosition = new THREE.Vector3();
        if (this.positionBuffer.length > 0) {
          this.positionBuffer.forEach(pos => averagedPosition.add(pos));
          averagedPosition.divideScalar(this.positionBuffer.length);
        } else {
          averagedPosition.copy(currentPosition);
        }
        this.el.object3D.position.lerp(averagedPosition, this.smoothingFactor);
        this.el.object3D.quaternion.slerp(currentQuaternion, this.smoothingFactor);
        this.lastPosition.copy(this.el.object3D.position);
        this.lastQuaternion.copy(this.el.object3D.quaternion);
      }
    });

    const sceneEl = document.querySelector('a-scene');
    const loadingScreen = document.getElementById('loading-screen');
    const welcomeMessage = document.getElementById('welcome-message');
    const helpButton = document.getElementById('help-button');
    const helpModal = document.getElementById('help-modal');
    const closeHelpButton = document.getElementById('close-help-button');

    // Function to hide a given element with fade-out
    const hideElement = (element) => {
      if (element.classList.contains('hidden') || element.style.display === 'none') {
        return; 
      }
      element.classList.add('hidden');
      element.addEventListener('transitionend', () => {
        element.style.display = 'none';
      }, { once: true });
      console.log(`${element.id} hidden.`);
    };

    // Function to show a given element (for modals)
    const showElement = (element) => {
        element.style.display = 'flex'; // Use flex to center content
        // Force reflow to ensure display change applies before opacity transition
        element.offsetWidth; 
        element.classList.remove('hidden');
        element.classList.add('visible'); // For modal specific visibility class
        console.log(`${element.id} shown.`);
    }

    // Hide the welcome message after 2.5 seconds (then it takes 4 seconds to fade)
    setTimeout(() => {
      hideElement(welcomeMessage);
    }, **2500**); // Changed to 2500 milliseconds (2.5 seconds)

    // Hide the loading screen when A-Frame scene is loaded
    const loadingScreenHideTimeout = setTimeout(() => {
        hideElement(loadingScreen);
    }, 5000); // Fallback for loading screen: hide after 5 seconds if 'loaded' event doesn't fire

    sceneEl.addEventListener('loaded', () => {
      clearTimeout(loadingScreenHideTimeout); // Clear fallback if loaded
      hideElement(loadingScreen); // Hide the loading screen
      console.log('A-Frame scene loaded, clearing loading screen timeout.');
    }, { once: true });

    // Event listeners for the help modal
    helpButton.addEventListener('click', () => {
        showElement(helpModal);
    });

    closeHelpButton.addEventListener('click', () => {
        // Use hideElement with a slight delay to allow transition, then remove 'visible' class
        helpModal.classList.remove('visible');
        helpModal.classList.add('hidden');
        helpModal.addEventListener('transitionend', () => {
          helpModal.style.display = 'none';
          helpModal.classList.remove('hidden'); // Clean up hidden class for next show
        }, { once: true });
    });


    // Renderer settings
    if (sceneEl.renderer) {
      sceneEl.renderer.setPixelRatio(window.devicePixelRatio || 1);
      sceneEl.renderer.sortObjects = false;
    }

    // Debugging console logs for target events
    sceneEl.addEventListener('targetFound', e => console.log('✅ Target found:', e.detail.targetIndex));
    sceneEl.addEventListener('targetLost', e => console.log('❌ Target lost:', e.detail.targetIndex));
</script>
